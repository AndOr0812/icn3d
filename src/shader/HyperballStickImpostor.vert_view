1: precision highp float;
2: precision highp int;
3: #define SHADER_NAME ShaderMaterial
4: #define NEAR_CLIP 1
5: #define CAP 1
6: #define VERTEX_TEXTURES
7: #define GAMMA_FACTOR 2
8: #define MAX_BONES 1019
9: #define NUM_CLIPPING_PLANES 0
10: uniform mat4 modelMatrix;
11: uniform mat4 modelViewMatrix;
12: uniform mat4 projectionMatrix;
13: uniform mat4 viewMatrix;
14: uniform mat3 normalMatrix;
15: uniform vec3 cameraPosition;
16: attribute vec3 position;
17: attribute vec3 normal;
18: attribute vec2 uv;
19: #ifdef USE_COLOR
20: 	attribute vec3 color;
21: #endif
22: #ifdef USE_MORPHTARGETS
23: 	attribute vec3 morphTarget0;
24: 	attribute vec3 morphTarget1;
25: 	attribute vec3 morphTarget2;
26: 	attribute vec3 morphTarget3;
27: 	#ifdef USE_MORPHNORMALS
28: 		attribute vec3 morphNormal0;
29: 		attribute vec3 morphNormal1;
30: 		attribute vec3 morphNormal2;
31: 		attribute vec3 morphNormal3;
32: 	#else
33: 		attribute vec3 morphTarget4;
34: 		attribute vec3 morphTarget5;
35: 		attribute vec3 morphTarget6;
36: 		attribute vec3 morphTarget7;
37: 	#endif
38: #endif
39: #ifdef USE_SKINNING
40: 	attribute vec4 skinIndex;
41: 	attribute vec4 skinWeight;
42: #endif
43: 
44: // Copyright (C) 2010-2011 by
45: // Laboratoire de Biochimie Theorique (CNRS),
46: // Laboratoire d'Informatique Fondamentale d'Orleans (Universite d'Orleans), (INRIA) and
47: // Departement des Sciences de la Simulation et de l'Information (CEA).
48: //
49: // License: CeCILL-C license (http://www.cecill.info/)
50: //
51: // Contact: Marc Baaden
52: // E-mail: baaden@smplinux.de
53: // Webpage: http://hyperballs.sourceforge.net
54: 
55: // Contributions by Alexander Rose
56: // - ported to WebGL
57: // - dual color
58: // - picking color
59: 
60: attribute vec3 mapping;
61: attribute float radius;
62: //attribute float radius2;
63: attribute vec3 position1;
64: attribute vec3 position2;
65: 
66: varying mat4 matrix_near;
67: varying vec4 prime1;
68: varying vec4 prime2;
69: varying float vRadius;
70: varying float vRadius2;
71: 
72: #ifdef PICKING
73:     
74:     attribute float primitiveId;
75:     varying vec3 vPickingColor;
76: #else
77:     attribute vec3 color;
78:     attribute vec3 color2;
79:     varying vec3 vColor1;
80:     varying vec3 vColor2;
81: #endif
82: 
83: uniform float shrink;
84: uniform mat4 modelViewProjectionMatrix;
85: uniform mat4 modelViewProjectionMatrixInverse;
86: 
87: void main(){
88: 
89:     float radius2 = radius;
90: 
91:     vRadius = radius;
92:     vRadius2 = radius2;
93: 
94:     vec4 spaceposition;
95:     vec3 position_atom1;
96:     vec3 position_atom2;
97:     vec4 vertex_position;
98: 
99:     #ifdef PICKING
100:         vPickingColor = unpackColor( primitiveId );
101:     #else
102:         vColor1 = color;
103:         vColor2 = color2;
104:     #endif
105: 
106:     float radius1 = radius;
107: 
108:     position_atom1 = position1;
109:     position_atom2 = position2;
110: 
111:     float distance = distance( position_atom1, position_atom2 );
112: 
113:     spaceposition.z = mapping.z * distance;
114: 
115:     if (radius1 > radius2) {
116:         spaceposition.y = mapping.y * 1.5 * radius1;
117:         spaceposition.x = mapping.x * 1.5 * radius1;
118:     } else {
119:         spaceposition.y = mapping.y * 1.5 * radius2;
120:         spaceposition.x = mapping.x * 1.5 * radius2;
121:     }
122:     spaceposition.w = 1.0;
123: 
124:     vec4 e3 = vec4( 1.0 );
125:     vec3 e1, e1_temp, e2, e2_temp;
126: 
127:     // Calculation of bond direction: e3
128:     e3.xyz = normalize(position_atom1-position_atom2);
129: 
130:     // little hack to avoid some problems of precision due to graphic card limitation using float: To improve soon
131:     if (e3.z == 0.0) { e3.z = 0.0000000000001;}
132:     if ( (position_atom1.x - position_atom2.x) == 0.0) { position_atom1.x += 0.001;}
133:     if ( (position_atom1.y - position_atom2.y) == 0.0) { position_atom1.y += 0.001;}
134:     if ( (position_atom1.z - position_atom2.z) == 0.0) { position_atom1.z += 0.001;}
135: 
136:     // Focus calculation
137:     vec4 focus = vec4( 1.0 );
138:     focus.x = ( position_atom1.x*position_atom1.x - position_atom2.x*position_atom2.x +
139:         ( radius2*radius2 - radius1*radius1 )*e3.x*e3.x/shrink )/(2.0*(position_atom1.x - position_atom2.x));
140:     focus.y = ( position_atom1.y*position_atom1.y - position_atom2.y*position_atom2.y +
141:         ( radius2*radius2 - radius1*radius1 )*e3.y*e3.y/shrink )/(2.0*(position_atom1.y - position_atom2.y));
142:     focus.z = ( position_atom1.z*position_atom1.z - position_atom2.z*position_atom2.z +
143:         ( radius2*radius2 - radius1*radius1 )*e3.z*e3.z/shrink )/(2.0*(position_atom1.z - position_atom2.z));
144: 
145:     // e1 calculation
146:     e1.x = 1.0;
147:     e1.y = 1.0;
148:     e1.z = ( (e3.x*focus.x + e3.y*focus.y + e3.z*focus.z) - e1.x*e3.x - e1.y*e3.y)/e3.z;
149:     e1_temp = e1 - focus.xyz;
150:     e1 = normalize(e1_temp);
151: 
152:     // e2 calculation
153:     e2_temp = e1.yzx * e3.zxy - e1.zxy * e3.yzx;
154:     e2 = normalize(e2_temp);
155: 
156:     //ROTATION:
157:     // final form of change of basis matrix:
158:     mat3 R= mat3( e1.xyz, e2.xyz, e3.xyz );
159:     // Apply rotation and translation to the bond primitive
160:     vertex_position.xyz = R * spaceposition.xyz;
161:     vertex_position.w = 1.0;
162: 
163:     // TRANSLATION:
164:     vertex_position.x += (position_atom1.x+position_atom2.x) / 2.0;
165:     vertex_position.y += (position_atom1.y+position_atom2.y) / 2.0;
166:     vertex_position.z += (position_atom1.z+position_atom2.z) / 2.0;
167: 
168:     // New position
169:     gl_Position = modelViewProjectionMatrix * vertex_position;
170: 
171:     vec4 i_near, i_far;
172: 
173:     // Calculate near from position
174:     vec4 near = gl_Position;
175:     near.z = 0.0 ;
176:     near = modelViewProjectionMatrixInverse * near;
177:     i_near = near;
178: 
179:     // Calculate far from position
180:     vec4 far = gl_Position;
181:     far.z = far.w ;
182:     i_far = modelViewProjectionMatrixInverse * far;
183: 
184:     prime1 = vec4( position_atom1 - (position_atom1 - focus.xyz)*shrink, 1.0 );
185:     prime2 = vec4( position_atom2 - (position_atom2 - focus.xyz)*shrink, 1.0 );
186: 
187:     float Rsquare = (radius1*radius1/shrink) - (
188:                         (position_atom1.x - focus.x)*(position_atom1.x - focus.x) +
189:                         (position_atom1.y - focus.y)*(position_atom1.y - focus.y) +
190:                         (position_atom1.z - focus.z)*(position_atom1.z - focus.z)
191:                     );
192: 
193:     focus.w = Rsquare;
194: 
195:     matrix_near = mat4( i_near, i_far, focus, e3 );
196: 
197:     // avoid clipping
198:     gl_Position.z = 1.0;
199: 
200: }
