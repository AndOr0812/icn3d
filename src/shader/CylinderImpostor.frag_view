 1: #extension GL_EXT_frag_depth : enable
2: precision highp float;
3: precision highp int;
4: #define SHADER_NAME ShaderMaterial
5: #define GAMMA_FACTOR 2
6: #define NUM_CLIPPING_PLANES 0
7: uniform mat4 viewMatrix;
8: uniform vec3 cameraPosition;
9: #define TONE_MAPPING
10: #define saturate(a) clamp( a, 0.0, 1.0 )
11: uniform float toneMappingExposure;
12: uniform float toneMappingWhitePoint;
13: vec3 LinearToneMapping( vec3 color ) {
14:   return toneMappingExposure * color;
15: }
16: vec3 ReinhardToneMapping( vec3 color ) {
17:   color *= toneMappingExposure;
18:   return saturate( color / ( vec3( 1.0 ) + color ) );
19: }
20: #define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
21: vec3 Uncharted2ToneMapping( vec3 color ) {
22:   color *= toneMappingExposure;
23:   return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
24: }
25: vec3 OptimizedCineonToneMapping( vec3 color ) {
26:   color *= toneMappingExposure;
27:   color = max( vec3( 0.0 ), color - 0.004 );
28:   return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
29: }
30: 
31: vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }
32: 
33: vec4 LinearToLinear( in vec4 value ) {
34:   return value;
35: }
36: vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
37:   return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
38: }
39: vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
40:   return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
41: }
42: vec4 sRGBToLinear( in vec4 value ) {
43:   return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
44: }
45: vec4 LinearTosRGB( in vec4 value ) {
46:   return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
47: }
48: vec4 RGBEToLinear( in vec4 value ) {
49:   return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
50: }
51: vec4 LinearToRGBE( in vec4 value ) {
52:   float maxComponent = max( max( value.r, value.g ), value.b );
53:   float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
54:   return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
55: }
56: vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
57:   return vec4( value.xyz * value.w * maxRange, 1.0 );
58: }
59: vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
60:   float maxRGB = max( value.x, max( value.g, value.b ) );
61:   float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
62:   M            = ceil( M * 255.0 ) / 255.0;
63:   return vec4( value.rgb / ( M * maxRange ), M );
64: }
65: vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
66:     return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
67: }
68: vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
69:     float maxRGB = max( value.x, max( value.g, value.b ) );
70:     float D      = max( maxRange / maxRGB, 1.0 );
71:     D            = min( floor( D ) / 255.0, 1.0 );
72:     return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
73: }
74: const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
75: vec4 LinearToLogLuv( in vec4 value )  {
76:   vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
77:   Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
78:   vec4 vResult;
79:   vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
80:   float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
81:   vResult.w = fract(Le);
82:   vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
83:   return vResult;
84: }
85: const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
86: vec4 LogLuvToLinear( in vec4 value ) {
87:   float Le = value.z * 255.0 + value.w;
88:   vec3 Xp_Y_XYZp;
89:   Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
90:   Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
91:   Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
92:   vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
93:   return vec4( max(vRGB, 0.0), 1.0 );
94: }
95: 
96: vec4 mapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
97: vec4 envMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
98: vec4 emissiveMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
99: vec4 linearToOutputTexel( vec4 value ) { return LinearToGamma( value, float( GAMMA_FACTOR ) ); }
100: 
101: #define STANDARD
102: #define IMPOSTOR
103: 
104: // Open-Source PyMOL is Copyright (C) Schrodinger, LLC.
105: //
106: //  All Rights Reserved
107: //
108: //  Permission to use, copy, modify, distribute, and distribute modified
109: //  versions of this software and its built-in documentation for any
110: //  purpose and without fee is hereby granted, provided that the above
111: //  copyright notice appears in all copies and that both the copyright
112: //  notice and this permission notice appear in supporting documentation,
113: //  and that the name of Schrodinger, LLC not be used in advertising or
114: //  publicity pertaining to distribution of the software without specific,
115: //  written prior permission.
116: //
117: //  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
118: //  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
119: //  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR
120: //  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
121: //  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
122: //  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
123: //  USE OR PERFORMANCE OF THIS SOFTWARE.
124: 
125: // Contributions by Alexander Rose
126: // - ported to WebGL
127: // - dual color
128: // - picking color
129: // - custom clipping
130: // - three.js lighting
131: 
132: uniform vec3 diffuse;
133: uniform vec3 emissive;
134: uniform float roughness;
135: uniform float metalness;
136: uniform float opacity;
137: uniform float nearClip;
138: uniform mat4 projectionMatrix;
139: uniform float ortho;
140: uniform vec3 direction;
141: 
142: varying vec3 axis;
143: varying vec4 base_radius;
144: varying vec4 end_b;
145: varying vec3 U;
146: varying vec3 V;
147: varying vec4 w;
148: 
149: #ifdef PICKING
150:     uniform float objectId;
151:     varying vec3 vPickingColor;
152: #else
153:     varying vec3 vColor1;
154:     varying vec3 vColor2;
155:     #define PI 3.14159265359
156: #define PI2 6.28318530718
157: #define RECIPROCAL_PI 0.31830988618
158: #define RECIPROCAL_PI2 0.15915494
159: #define LOG2 1.442695
160: #define EPSILON 1e-6
161: #define saturate(a) clamp( a, 0.0, 1.0 )
162: #define whiteCompliment(a) ( 1.0 - saturate( a ) )
163: float pow2( const in float x ) { return x*x; }
164: float pow3( const in float x ) { return x*x*x; }
165: float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
166: float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
167: highp float rand( const in vec2 uv ) {
168: 	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
169: 	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
170: 	return fract(sin(sn) * c);
171: }
172: struct IncidentLight {
173: 	vec3 color;
174: 	vec3 direction;
175: 	bool visible;
176: };
177: struct ReflectedLight {
178: 	vec3 directDiffuse;
179: 	vec3 directSpecular;
180: 	vec3 indirectDiffuse;
181: 	vec3 indirectSpecular;
182: };
183: struct GeometricContext {
184: 	vec3 position;
185: 	vec3 normal;
186: 	vec3 viewDir;
187: };
188: vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
189: 	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
190: }
191: vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
192: 	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
193: }
194: vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
195: 	float distance = dot( planeNormal, point - pointOnPlane );
196: 	return - distance * planeNormal + point;
197: }
198: float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
199: 	return sign( dot( point - pointOnPlane, planeNormal ) );
200: }
201: vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
202: 	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
203: }
204: 
205:     #ifdef USE_FOG
206: 	uniform vec3 fogColor;
207: 	#ifdef FOG_EXP2
208: 		uniform float fogDensity;
209: 	#else
210: 		uniform float fogNear;
211: 		uniform float fogFar;
212: 	#endif
213: #endif
214:     bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {
215: 	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );
216: }
217: float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
218: 		if( decayExponent > 0.0 ) {
219: #if defined ( PHYSICALLY_CORRECT_LIGHTS )
220: 			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
221: 			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
222: 			return distanceFalloff * maxDistanceCutoffFactor;
223: #else
224: 			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
225: #endif
226: 		}
227: 		return 1.0;
228: }
229: vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
230: 	return RECIPROCAL_PI * diffuseColor;
231: }
232: vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
233: 	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
234: 	return ( 1.0 - specularColor ) * fresnel + specularColor;
235: }
236: float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
237: 	float a2 = pow2( alpha );
238: 	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
239: 	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
240: 	return 1.0 / ( gl * gv );
241: }
242: float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
243: 	float a2 = pow2( alpha );
244: 	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
245: 	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
246: 	return 0.5 / max( gv + gl, EPSILON );
247: }
248: float D_GGX( const in float alpha, const in float dotNH ) {
249: 	float a2 = pow2( alpha );
250: 	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
251: 	return RECIPROCAL_PI * a2 / pow2( denom );
252: }
253: vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
254: 	float alpha = pow2( roughness );
255: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
256: 	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
257: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
258: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
259: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
260: 	vec3 F = F_Schlick( specularColor, dotLH );
261: 	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
262: 	float D = D_GGX( alpha, dotNH );
263: 	return F * ( G * D );
264: }
265: vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
266: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
267: 	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
268: 	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
269: 	vec4 r = roughness * c0 + c1;
270: 	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
271: 	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
272: 	return specularColor * AB.x + AB.y;
273: }
274: float G_BlinnPhong_Implicit( ) {
275: 	return 0.25;
276: }
277: float D_BlinnPhong( const in float shininess, const in float dotNH ) {
278: 	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
279: }
280: vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
281: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
282: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
283: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
284: 	vec3 F = F_Schlick( specularColor, dotLH );
285: 	float G = G_BlinnPhong_Implicit( );
286: 	float D = D_BlinnPhong( shininess, dotNH );
287: 	return F * ( G * D );
288: }
289: float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
290: 	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
291: }
292: float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
293: 	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
294: }
295: 
296:     uniform vec3 ambientLightColor;
297: vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
298: 	vec3 irradiance = ambientLightColor;
299: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
300: 		irradiance *= PI;
301: 	#endif
302: 	return irradiance;
303: }
304: #if 1 > 0
305: 	struct DirectionalLight {
306: 		vec3 direction;
307: 		vec3 color;
308: 		int shadow;
309: 		float shadowBias;
310: 		float shadowRadius;
311: 		vec2 shadowMapSize;
312: 	};
313: 	uniform DirectionalLight directionalLights[ 1 ];
314: 	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
315: 		directLight.color = directionalLight.color;
316: 		directLight.direction = directionalLight.direction;
317: 		directLight.visible = true;
318: 	}
319: #endif
320: #if 0 > 0
321: 	struct PointLight {
322: 		vec3 position;
323: 		vec3 color;
324: 		float distance;
325: 		float decay;
326: 		int shadow;
327: 		float shadowBias;
328: 		float shadowRadius;
329: 		vec2 shadowMapSize;
330: 	};
331: 	uniform PointLight pointLights[ 0 ];
332: 	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
333: 		vec3 lVector = pointLight.position - geometry.position;
334: 		directLight.direction = normalize( lVector );
335: 		float lightDistance = length( lVector );
336: 		if ( testLightInRange( lightDistance, pointLight.distance ) ) {
337: 			directLight.color = pointLight.color;
338: 			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
339: 			directLight.visible = true;
340: 		} else {
341: 			directLight.color = vec3( 0.0 );
342: 			directLight.visible = false;
343: 		}
344: 	}
345: #endif
346: #if 0 > 0
347: 	struct SpotLight {
348: 		vec3 position;
349: 		vec3 direction;
350: 		vec3 color;
351: 		float distance;
352: 		float decay;
353: 		float coneCos;
354: 		float penumbraCos;
355: 		int shadow;
356: 		float shadowBias;
357: 		float shadowRadius;
358: 		vec2 shadowMapSize;
359: 	};
360: 	uniform SpotLight spotLights[ 0 ];
361: 	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
362: 		vec3 lVector = spotLight.position - geometry.position;
363: 		directLight.direction = normalize( lVector );
364: 		float lightDistance = length( lVector );
365: 		float angleCos = dot( directLight.direction, spotLight.direction );
366: 		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {
367: 			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
368: 			directLight.color = spotLight.color;
369: 			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
370: 			directLight.visible = true;
371: 		} else {
372: 			directLight.color = vec3( 0.0 );
373: 			directLight.visible = false;
374: 		}
375: 	}
376: #endif
377: #if 0 > 0
378: 	struct HemisphereLight {
379: 		vec3 direction;
380: 		vec3 skyColor;
381: 		vec3 groundColor;
382: 	};
383: 	uniform HemisphereLight hemisphereLights[ 0 ];
384: 	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
385: 		float dotNL = dot( geometry.normal, hemiLight.direction );
386: 		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
387: 		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
388: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
389: 			irradiance *= PI;
390: 		#endif
391: 		return irradiance;
392: 	}
393: #endif
394: #if defined( USE_ENVMAP ) && defined( PHYSICAL )
395: 	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
396: 		#ifdef DOUBLE_SIDED
397: 	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
398: #else
399: 	float flipNormal = 1.0;
400: #endif
401: 
402: 		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
403: 		#ifdef ENVMAP_TYPE_CUBE
404: 			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
405: 			#ifdef TEXTURE_LOD_EXT
406: 				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
407: 			#else
408: 				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
409: 			#endif
410: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
411: 		#elif defined( ENVMAP_TYPE_CUBE_UV )
412: 			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
413: 			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );
414: 		#else
415: 			vec4 envMapColor = vec4( 0.0 );
416: 		#endif
417: 		return PI * envMapColor.rgb * envMapIntensity;
418: 	}
419: 	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
420: 		float maxMIPLevelScalar = float( maxMIPLevel );
421: 		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
422: 		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
423: 	}
424: 	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
425: 		#ifdef ENVMAP_MODE_REFLECTION
426: 			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
427: 		#else
428: 			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
429: 		#endif
430: 		#ifdef DOUBLE_SIDED
431: 	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
432: #else
433: 	float flipNormal = 1.0;
434: #endif
435: 
436: 		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
437: 		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
438: 		#ifdef ENVMAP_TYPE_CUBE
439: 			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
440: 			#ifdef TEXTURE_LOD_EXT
441: 				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
442: 			#else
443: 				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
444: 			#endif
445: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
446: 		#elif defined( ENVMAP_TYPE_CUBE_UV )
447: 			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
448: 			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));
449: 		#elif defined( ENVMAP_TYPE_EQUIREC )
450: 			vec2 sampleUV;
451: 			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
452: 			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
453: 			#ifdef TEXTURE_LOD_EXT
454: 				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
455: 			#else
456: 				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
457: 			#endif
458: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
459: 		#elif defined( ENVMAP_TYPE_SPHERE )
460: 			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
461: 			#ifdef TEXTURE_LOD_EXT
462: 				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
463: 			#else
464: 				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
465: 			#endif
466: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
467: 		#endif
468: 		return envMapColor.rgb * envMapIntensity;
469: 	}
470: #endif
471: 
472:     struct PhysicalMaterial {
473: 	vec3	diffuseColor;
474: 	float	specularRoughness;
475: 	vec3	specularColor;
476: 	#ifndef STANDARD
477: 		float clearCoat;
478: 		float clearCoatRoughness;
479: 	#endif
480: };
481: #define MAXIMUM_SPECULAR_COEFFICIENT 0.16
482: #define DEFAULT_SPECULAR_COEFFICIENT 0.04
483: float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
484: 	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
485: }
486: void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
487: 	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
488: 	vec3 irradiance = dotNL * directLight.color;
489: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
490: 		irradiance *= PI;
491: 	#endif
492: 	#ifndef STANDARD
493: 		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
494: 	#else
495: 		float clearCoatDHR = 0.0;
496: 	#endif
497: 	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
498: 	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
499: 	#ifndef STANDARD
500: 		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
501: 	#endif
502: }
503: void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
504: 	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
505: }
506: void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
507: 	#ifndef STANDARD
508: 		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
509: 		float dotNL = dotNV;
510: 		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
511: 	#else
512: 		float clearCoatDHR = 0.0;
513: 	#endif
514: 	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
515: 	#ifndef STANDARD
516: 		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
517: 	#endif
518: }
519: #define RE_Direct				RE_Direct_Physical
520: #define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
521: #define RE_IndirectSpecular		RE_IndirectSpecular_Physical
522: #define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
523: #define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
524: float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
525: 	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
526: }
527: 
528: #endif
529: 
530: bool interior = false;
531: 
532: float distSq3( vec3 v3a, vec3 v3b ){
533:     return (
534:         ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +
535:         ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +
536:         ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )
537:     );
538: }
539: 
540: // Calculate depth based on the given camera position.
541: float calcDepth( in vec3 cameraPos ){
542:     vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;
543:     return 0.5 + 0.5 * clipZW.x / clipZW.y;
544: }
545: 
546: float calcClip( vec3 cameraPos ){
547:     return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );
548: }
549: 
550: void main(){
551: 
552:     vec3 point = w.xyz / w.w;
553: 
554:     // unpacking
555:     vec3 base = base_radius.xyz;
556:     float vRadius = base_radius.w;
557:     vec3 end = end_b.xyz;
558:     float b = end_b.w;
559: 
560:     vec3 end_cyl = end;
561:     vec3 surface_point = point;
562: 
563:     vec3 ray_target = surface_point;
564:     vec3 ray_origin = vec3(0.0);
565:     vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);
566:     mat3 basis = mat3( U, V, axis );
567: 
568:     vec3 diff = ray_target - 0.5 * (base + end_cyl);
569:     vec3 P = diff * basis;
570: 
571:     // angle (cos) between cylinder cylinder_axis and ray direction
572:     float dz = dot( axis, ray_direction );
573: 
574:     float radius2 = vRadius*vRadius;
575: 
576:     // calculate distance to the cylinder from ray origin
577:     vec3 D = vec3(dot(U, ray_direction),
578:                 dot(V, ray_direction),
579:                 dz);
580:     float a0 = P.x*P.x + P.y*P.y - radius2;
581:     float a1 = P.x*D.x + P.y*D.y;
582:     float a2 = D.x*D.x + D.y*D.y;
583: 
584:     // calculate a dicriminant of the above quadratic equation
585:     float d = a1*a1 - a0*a2;
586:     if (d < 0.0)
587:         // outside of the cylinder
588:         discard;
589: 
590:     float dist = (-a1 + sqrt(d)) / a2;
591: 
592:     // point of intersection on cylinder surface
593:     vec3 new_point = ray_target + dist * ray_direction;
594: 
595:     vec3 tmp_point = new_point - base;
596:     vec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );
597: 
598:     ray_origin = mix( ray_origin, surface_point, ortho );
599: 
600:     // test caps
601:     float front_cap_test = dot( tmp_point, axis );
602:     float end_cap_test = dot((new_point - end_cyl), axis);
603: 
604:     // to calculate caps, simply check the angle between
605:     // the point of intersection - cylinder end vector
606:     // and a cap plane normal (which is the cylinder cylinder_axis)
607:     // if the angle < 0, the point is outside of cylinder
608:     // test front cap
609: 
610:     #ifndef CAP
611:         vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;
612:         vec3 tmp_point2 = new_point2 - base;
613:     #endif
614: 
615:     // flat
616:     if (front_cap_test < 0.0)
617:     {
618:         // ray-plane intersection
619:         float dNV = dot(-axis, ray_direction);
620:         if (dNV < 0.0)
621:             discard;
622:         float near = dot(-axis, (base)) / dNV;
623:         vec3 front_point = ray_direction * near + ray_origin;
624:         // within the cap radius?
625:         if (dot(front_point - base, front_point-base) > radius2)
626:             discard;
627: 
628:         #ifdef CAP
629:             new_point = front_point;
630:             _normal = axis;
631:         #else
632:             new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;
633:             dNV = dot(-axis, ray_direction);
634:             near = dot(axis, end_cyl) / dNV;
635:             new_point2 = ray_direction * near + ray_origin;
636:             if (dot(new_point2 - end_cyl, new_point2-base) < radius2)
637:                 discard;
638:             interior = true;
639:         #endif
640:     }
641: 
642:     // test end cap
643: 
644: 
645:     // flat
646:     if( end_cap_test > 0.0 )
647:     {
648:         // ray-plane intersection
649:         float dNV = dot(axis, ray_direction);
650:         if (dNV < 0.0)
651:             discard;
652:         float near = dot(axis, end_cyl) / dNV;
653:         vec3 end_point = ray_direction * near + ray_origin;
654:         // within the cap radius?
655:         if( dot(end_point - end_cyl, end_point-base) > radius2 )
656:             discard;
657: 
658:         #ifdef CAP
659:             new_point = end_point;
660:             _normal = axis;
661:         #else
662:             new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;
663:             dNV = dot(-axis, ray_direction);
664:             near = dot(-axis, (base)) / dNV;
665:             new_point2 = ray_direction * near + ray_origin;
666:             if (dot(new_point2 - base, new_point2-base) < radius2)
667:                 discard;
668:             interior = true;
669:         #endif
670:     }
671: 
672:     gl_FragDepthEXT = calcDepth( new_point );
673: 
674:     #ifdef NEAR_CLIP
675:         if( calcClip( new_point ) > 0.0 ){
676:             dist = (-a1 - sqrt(d)) / a2;
677:             new_point = ray_target + dist * ray_direction;
678:             if( calcClip( new_point ) > 0.0 )
679:                 discard;
680:             interior = true;
681:             gl_FragDepthEXT = calcDepth( new_point );
682:             if( gl_FragDepthEXT >= 0.0 ){
683:                 gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );
684:             }
685:         }else if( gl_FragDepthEXT <= 0.0 ){
686:             dist = (-a1 - sqrt(d)) / a2;
687:             new_point = ray_target + dist * ray_direction;
688:             interior = true;
689:             gl_FragDepthEXT = calcDepth( new_point );
690:             if( gl_FragDepthEXT >= 0.0 ){
691:                 gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );
692:             }
693:         }
694:     #else
695:         if( gl_FragDepthEXT <= 0.0 ){
696:             dist = (-a1 - sqrt(d)) / a2;
697:             new_point = ray_target + dist * ray_direction;
698:             interior = true;
699:             gl_FragDepthEXT = calcDepth( new_point );
700:             if( gl_FragDepthEXT >= 0.0 ){
701:                 gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );
702:             }
703:         }
704:     #endif
705: 
706:     // this is a workaround necessary for Mac
707:     // otherwise the modified fragment won't clip properly
708:     if (gl_FragDepthEXT < 0.0)
709:         discard;
710:     if (gl_FragDepthEXT > 1.0)
711:         discard;
712: 
713:     #ifdef PICKING
714: 
715:         gl_FragColor = vec4( vPickingColor, objectId );
716: 
717:     #else
718: 
719:         vec3 vViewPosition = -new_point;
720:         vec3 vNormal = _normal;
721:         vec3 vColor;
722: 
723:         if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){
724:             if( b < 0.0 ){
725:                 vColor = vColor1;
726:             }else{
727:                 vColor = vColor2;
728:             }
729:         }else{
730:             if( b > 0.0 ){
731:                 vColor = vColor1;
732:             }else{
733:                 vColor = vColor2;
734:             }
735:         }
736: 
737:         vec4 diffuseColor = vec4( diffuse, opacity );
738:         ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
739:         vec3 totalEmissiveLight = emissive;
740: 
741:         #ifdef USE_COLOR
742: 	diffuseColor.rgb *= vColor;
743: #endif
744:         float roughnessFactor = roughness;
745: #ifdef USE_ROUGHNESSMAP
746: 	vec4 texelRoughness = texture2D( roughnessMap, vUv );
747: 	roughnessFactor *= texelRoughness.r;
748: #endif
749: 
750:         float metalnessFactor = metalness;
751: #ifdef USE_METALNESSMAP
752: 	vec4 texelMetalness = texture2D( metalnessMap, vUv );
753: 	metalnessFactor *= texelMetalness.r;
754: #endif
755: 
756: 
757:         // don't use include normal_fragment
758:         vec3 normal = normalize( vNormal );
759:         if( interior ){
760:             normal = vec3( 0.0, 0.0, 0.4 );
761:         }
762: 
763:         PhysicalMaterial material;
764: material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
765: material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
766: #ifdef STANDARD
767: 	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
768: #else
769: 	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
770: 	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
771: #endif
772: 
773:         
774: GeometricContext geometry;
775: geometry.position = - vViewPosition;
776: geometry.normal = normal;
777: geometry.viewDir = normalize( vViewPosition );
778: IncidentLight directLight;
779: #if ( 0 > 0 ) && defined( RE_Direct )
780: 	PointLight pointLight;
781: 	for ( int i = 0; i < 0; i ++ ) {
782: 		pointLight = pointLights[ i ];
783: 		getPointDirectLightIrradiance( pointLight, geometry, directLight );
784: 		#ifdef USE_SHADOWMAP
785: 		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;
786: 		#endif
787: 		RE_Direct( directLight, geometry, material, reflectedLight );
788: 	}
789: #endif
790: #if ( 0 > 0 ) && defined( RE_Direct )
791: 	SpotLight spotLight;
792: 	for ( int i = 0; i < 0; i ++ ) {
793: 		spotLight = spotLights[ i ];
794: 		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
795: 		#ifdef USE_SHADOWMAP
796: 		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
797: 		#endif
798: 		RE_Direct( directLight, geometry, material, reflectedLight );
799: 	}
800: #endif
801: #if ( 1 > 0 ) && defined( RE_Direct )
802: 	DirectionalLight directionalLight;
803: 	for ( int i = 0; i < 1; i ++ ) {
804: 		directionalLight = directionalLights[ i ];
805: 		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
806: 		#ifdef USE_SHADOWMAP
807: 		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
808: 		#endif
809: 		RE_Direct( directLight, geometry, material, reflectedLight );
810: 	}
811: #endif
812: #if defined( RE_IndirectDiffuse )
813: 	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
814: 	#ifdef USE_LIGHTMAP
815: 		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
816: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
817: 			lightMapIrradiance *= PI;
818: 		#endif
819: 		irradiance += lightMapIrradiance;
820: 	#endif
821: 	#if ( 0 > 0 )
822: 		for ( int i = 0; i < 0; i ++ ) {
823: 			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
824: 		}
825: 	#endif
826: 	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
827: 	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );
828: 	#endif
829: 	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
830: #endif
831: #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
832: 	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );
833: 	#ifndef STANDARD
834: 		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );
835: 	#else
836: 		vec3 clearCoatRadiance = vec3( 0.0 );
837: 	#endif
838: 		
839: 	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
840: #endif
841: 
842: 
843:         vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;
844: 
845:         //gl_FragColor = vec4( outgoingLight, diffuseColor.a );
846:         gl_FragColor = vec42( diffuseColor.rgb, diffuseColor.a );
847: 
848:         #ifdef PREMULTIPLIED_ALPHA
849: 	gl_FragColor.rgb *= gl_FragColor.a;
850: #endif
851: 
852:         #if defined( TONE_MAPPING )
853:   gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
854: #endif
855: 
856:           gl_FragColor = linearToOutputTexel( gl_FragColor );
857: 
858:         #ifdef USE_FOG
859: 	#ifdef USE_LOGDEPTHBUF_EXT
860: 		float depth = gl_FragDepthEXT / gl_FragCoord.w;
861: 	#else
862: 		float depth = gl_FragCoord.z / gl_FragCoord.w;
863: 	#endif
864: 	#ifdef FOG_EXP2
865: 		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
866: 	#else
867: 		float fogFactor = smoothstep( fogNear, fogFar, depth );
868: 	#endif
869: 	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
870: #endif
871: 
872: 
873:     #endif
874: 
875: }
