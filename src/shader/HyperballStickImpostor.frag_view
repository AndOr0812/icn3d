1: #extension GL_EXT_frag_depth : enable
2: precision highp float;
3: precision highp int;
4: #define SHADER_NAME ShaderMaterial
5: #define USE_COLOR 1
6: #define NEAR_CLIP 1
7: #define CAP 1
8: #define GAMMA_FACTOR 2
9: #define NUM_CLIPPING_PLANES 0
10: uniform mat4 viewMatrix;
11: uniform vec3 cameraPosition;
12: #define TONE_MAPPING
13: #define saturate(a) clamp( a, 0.0, 1.0 )
14: uniform float toneMappingExposure;
15: uniform float toneMappingWhitePoint;
16: vec3 LinearToneMapping( vec3 color ) {
17:   return toneMappingExposure * color;
18: }
19: vec3 ReinhardToneMapping( vec3 color ) {
20:   color *= toneMappingExposure;
21:   return saturate( color / ( vec3( 1.0 ) + color ) );
22: }
23: #define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
24: vec3 Uncharted2ToneMapping( vec3 color ) {
25:   color *= toneMappingExposure;
26:   return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
27: }
28: vec3 OptimizedCineonToneMapping( vec3 color ) {
29:   color *= toneMappingExposure;
30:   color = max( vec3( 0.0 ), color - 0.004 );
31:   return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
32: }
33: 
34: vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }
35: 
36: vec4 LinearToLinear( in vec4 value ) {
37:   return value;
38: }
39: vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
40:   return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
41: }
42: vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
43:   return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
44: }
45: vec4 sRGBToLinear( in vec4 value ) {
46:   return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
47: }
48: vec4 LinearTosRGB( in vec4 value ) {
49:   return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
50: }
51: vec4 RGBEToLinear( in vec4 value ) {
52:   return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
53: }
54: vec4 LinearToRGBE( in vec4 value ) {
55:   float maxComponent = max( max( value.r, value.g ), value.b );
56:   float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
57:   return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
58: }
59: vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
60:   return vec4( value.xyz * value.w * maxRange, 1.0 );
61: }
62: vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
63:   float maxRGB = max( value.x, max( value.g, value.b ) );
64:   float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
65:   M            = ceil( M * 255.0 ) / 255.0;
66:   return vec4( value.rgb / ( M * maxRange ), M );
67: }
68: vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
69:     return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
70: }
71: vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
72:     float maxRGB = max( value.x, max( value.g, value.b ) );
73:     float D      = max( maxRange / maxRGB, 1.0 );
74:     D            = min( floor( D ) / 255.0, 1.0 );
75:     return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
76: }
77: const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
78: vec4 LinearToLogLuv( in vec4 value )  {
79:   vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
80:   Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
81:   vec4 vResult;
82:   vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
83:   float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
84:   vResult.w = fract(Le);
85:   vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
86:   return vResult;
87: }
88: const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
89: vec4 LogLuvToLinear( in vec4 value ) {
90:   float Le = value.z * 255.0 + value.w;
91:   vec3 Xp_Y_XYZp;
92:   Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
93:   Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
94:   Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
95:   vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
96:   return vec4( max(vRGB, 0.0), 1.0 );
97: }
98: 
99: vec4 mapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
100: vec4 envMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
101: vec4 emissiveMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }
102: vec4 linearToOutputTexel( vec4 value ) { return LinearToGamma( value, float( GAMMA_FACTOR ) ); }
103: 
104: #define STANDARD
105: #define IMPOSTOR
106: 
107: // Copyright (C) 2010-2011 by
108: // Laboratoire de Biochimie Theorique (CNRS),
109: // Laboratoire d'Informatique Fondamentale d'Orleans (Universite d'Orleans), (INRIA) and
110: // Departement des Sciences de la Simulation et de l'Information (CEA).
111: //
112: // License: CeCILL-C license (http://www.cecill.info/)
113: //
114: // Contact: Marc Baaden
115: // E-mail: baaden@smplinux.de
116: // Webpage: http://hyperballs.sourceforge.net
117: 
118: // Contributions by Alexander Rose
119: // - ported to WebGL
120: // - dual color
121: // - picking color
122: // - custom clipping
123: // - three.js lighting
124: 
125: uniform vec3 diffuse;
126: uniform vec3 emissive;
127: uniform float roughness;
128: uniform float metalness;
129: uniform float opacity;
130: uniform float nearClip;
131: uniform float shrink;
132: uniform mat4 modelViewMatrix;
133: uniform mat4 modelViewProjectionMatrix;
134: uniform mat4 modelViewMatrixInverseTranspose;
135: uniform mat4 projectionMatrix;
136: 
137: varying mat4 matrix_near;
138: varying vec4 prime1;
139: varying vec4 prime2;
140: varying float vRadius;
141: varying float vRadius2;
142: 
143: #ifdef PICKING
144:     uniform float objectId;
145:     varying vec3 vPickingColor;
146: #else
147:     varying vec3 vColor1;
148:     varying vec3 vColor2;
149:     #define PI 3.14159265359
150: #define PI2 6.28318530718
151: #define RECIPROCAL_PI 0.31830988618
152: #define RECIPROCAL_PI2 0.15915494
153: #define LOG2 1.442695
154: #define EPSILON 1e-6
155: #define saturate(a) clamp( a, 0.0, 1.0 )
156: #define whiteCompliment(a) ( 1.0 - saturate( a ) )
157: float pow2( const in float x ) { return x*x; }
158: float pow3( const in float x ) { return x*x*x; }
159: float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
160: float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
161: highp float rand( const in vec2 uv ) {
162: 	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
163: 	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
164: 	return fract(sin(sn) * c);
165: }
166: struct IncidentLight {
167: 	vec3 color;
168: 	vec3 direction;
169: 	bool visible;
170: };
171: struct ReflectedLight {
172: 	vec3 directDiffuse;
173: 	vec3 directSpecular;
174: 	vec3 indirectDiffuse;
175: 	vec3 indirectSpecular;
176: };
177: struct GeometricContext {
178: 	vec3 position;
179: 	vec3 normal;
180: 	vec3 viewDir;
181: };
182: vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
183: 	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
184: }
185: vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
186: 	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
187: }
188: vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
189: 	float distance = dot( planeNormal, point - pointOnPlane );
190: 	return - distance * planeNormal + point;
191: }
192: float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
193: 	return sign( dot( point - pointOnPlane, planeNormal ) );
194: }
195: vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
196: 	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
197: }
198: 
199:     #ifdef USE_FOG
200: 	uniform vec3 fogColor;
201: 	#ifdef FOG_EXP2
202: 		uniform float fogDensity;
203: 	#else
204: 		uniform float fogNear;
205: 		uniform float fogFar;
206: 	#endif
207: #endif
208:     bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {
209: 	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );
210: }
211: float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
212: 		if( decayExponent > 0.0 ) {
213: #if defined ( PHYSICALLY_CORRECT_LIGHTS )
214: 			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
215: 			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
216: 			return distanceFalloff * maxDistanceCutoffFactor;
217: #else
218: 			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
219: #endif
220: 		}
221: 		return 1.0;
222: }
223: vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
224: 	return RECIPROCAL_PI * diffuseColor;
225: }
226: vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
227: 	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
228: 	return ( 1.0 - specularColor ) * fresnel + specularColor;
229: }
230: float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
231: 	float a2 = pow2( alpha );
232: 	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
233: 	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
234: 	return 1.0 / ( gl * gv );
235: }
236: float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
237: 	float a2 = pow2( alpha );
238: 	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
239: 	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
240: 	return 0.5 / max( gv + gl, EPSILON );
241: }
242: float D_GGX( const in float alpha, const in float dotNH ) {
243: 	float a2 = pow2( alpha );
244: 	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
245: 	return RECIPROCAL_PI * a2 / pow2( denom );
246: }
247: vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
248: 	float alpha = pow2( roughness );
249: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
250: 	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
251: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
252: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
253: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
254: 	vec3 F = F_Schlick( specularColor, dotLH );
255: 	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
256: 	float D = D_GGX( alpha, dotNH );
257: 	return F * ( G * D );
258: }
259: vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
260: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
261: 	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
262: 	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
263: 	vec4 r = roughness * c0 + c1;
264: 	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
265: 	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
266: 	return specularColor * AB.x + AB.y;
267: }
268: float G_BlinnPhong_Implicit( ) {
269: 	return 0.25;
270: }
271: float D_BlinnPhong( const in float shininess, const in float dotNH ) {
272: 	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
273: }
274: vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
275: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
276: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
277: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
278: 	vec3 F = F_Schlick( specularColor, dotLH );
279: 	float G = G_BlinnPhong_Implicit( );
280: 	float D = D_BlinnPhong( shininess, dotNH );
281: 	return F * ( G * D );
282: }
283: float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
284: 	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
285: }
286: float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
287: 	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
288: }
289: 
290:     uniform vec3 ambientLightColor;
291: vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
292: 	vec3 irradiance = ambientLightColor;
293: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
294: 		irradiance *= PI;
295: 	#endif
296: 	return irradiance;
297: }
298: #if 1 > 0
299: 	struct DirectionalLight {
300: 		vec3 direction;
301: 		vec3 color;
302: 		int shadow;
303: 		float shadowBias;
304: 		float shadowRadius;
305: 		vec2 shadowMapSize;
306: 	};
307: 	uniform DirectionalLight directionalLights[ 1 ];
308: 	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
309: 		directLight.color = directionalLight.color;
310: 		directLight.direction = directionalLight.direction;
311: 		directLight.visible = true;
312: 	}
313: #endif
314: #if 0 > 0
315: 	struct PointLight {
316: 		vec3 position;
317: 		vec3 color;
318: 		float distance;
319: 		float decay;
320: 		int shadow;
321: 		float shadowBias;
322: 		float shadowRadius;
323: 		vec2 shadowMapSize;
324: 	};
325: 	uniform PointLight pointLights[ 0 ];
326: 	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
327: 		vec3 lVector = pointLight.position - geometry.position;
328: 		directLight.direction = normalize( lVector );
329: 		float lightDistance = length( lVector );
330: 		if ( testLightInRange( lightDistance, pointLight.distance ) ) {
331: 			directLight.color = pointLight.color;
332: 			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
333: 			directLight.visible = true;
334: 		} else {
335: 			directLight.color = vec3( 0.0 );
336: 			directLight.visible = false;
337: 		}
338: 	}
339: #endif
340: #if 0 > 0
341: 	struct SpotLight {
342: 		vec3 position;
343: 		vec3 direction;
344: 		vec3 color;
345: 		float distance;
346: 		float decay;
347: 		float coneCos;
348: 		float penumbraCos;
349: 		int shadow;
350: 		float shadowBias;
351: 		float shadowRadius;
352: 		vec2 shadowMapSize;
353: 	};
354: 	uniform SpotLight spotLights[ 0 ];
355: 	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
356: 		vec3 lVector = spotLight.position - geometry.position;
357: 		directLight.direction = normalize( lVector );
358: 		float lightDistance = length( lVector );
359: 		float angleCos = dot( directLight.direction, spotLight.direction );
360: 		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {
361: 			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
362: 			directLight.color = spotLight.color;
363: 			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
364: 			directLight.visible = true;
365: 		} else {
366: 			directLight.color = vec3( 0.0 );
367: 			directLight.visible = false;
368: 		}
369: 	}
370: #endif
371: #if 0 > 0
372: 	struct HemisphereLight {
373: 		vec3 direction;
374: 		vec3 skyColor;
375: 		vec3 groundColor;
376: 	};
377: 	uniform HemisphereLight hemisphereLights[ 0 ];
378: 	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
379: 		float dotNL = dot( geometry.normal, hemiLight.direction );
380: 		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
381: 		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
382: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
383: 			irradiance *= PI;
384: 		#endif
385: 		return irradiance;
386: 	}
387: #endif
388: #if defined( USE_ENVMAP ) && defined( PHYSICAL )
389: 	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
390: 		#ifdef DOUBLE_SIDED
391: 	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
392: #else
393: 	float flipNormal = 1.0;
394: #endif
395: 
396: 		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
397: 		#ifdef ENVMAP_TYPE_CUBE
398: 			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
399: 			#ifdef TEXTURE_LOD_EXT
400: 				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
401: 			#else
402: 				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
403: 			#endif
404: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
405: 		#elif defined( ENVMAP_TYPE_CUBE_UV )
406: 			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
407: 			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );
408: 		#else
409: 			vec4 envMapColor = vec4( 0.0 );
410: 		#endif
411: 		return PI * envMapColor.rgb * envMapIntensity;
412: 	}
413: 	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
414: 		float maxMIPLevelScalar = float( maxMIPLevel );
415: 		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
416: 		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
417: 	}
418: 	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
419: 		#ifdef ENVMAP_MODE_REFLECTION
420: 			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
421: 		#else
422: 			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
423: 		#endif
424: 		#ifdef DOUBLE_SIDED
425: 	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
426: #else
427: 	float flipNormal = 1.0;
428: #endif
429: 
430: 		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
431: 		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
432: 		#ifdef ENVMAP_TYPE_CUBE
433: 			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
434: 			#ifdef TEXTURE_LOD_EXT
435: 				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
436: 			#else
437: 				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
438: 			#endif
439: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
440: 		#elif defined( ENVMAP_TYPE_CUBE_UV )
441: 			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
442: 			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));
443: 		#elif defined( ENVMAP_TYPE_EQUIREC )
444: 			vec2 sampleUV;
445: 			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );
446: 			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
447: 			#ifdef TEXTURE_LOD_EXT
448: 				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
449: 			#else
450: 				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
451: 			#endif
452: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
453: 		#elif defined( ENVMAP_TYPE_SPHERE )
454: 			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
455: 			#ifdef TEXTURE_LOD_EXT
456: 				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
457: 			#else
458: 				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
459: 			#endif
460: 			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
461: 		#endif
462: 		return envMapColor.rgb * envMapIntensity;
463: 	}
464: #endif
465: 
466:     struct PhysicalMaterial {
467: 	vec3	diffuseColor;
468: 	float	specularRoughness;
469: 	vec3	specularColor;
470: 	#ifndef STANDARD
471: 		float clearCoat;
472: 		float clearCoatRoughness;
473: 	#endif
474: };
475: #define MAXIMUM_SPECULAR_COEFFICIENT 0.16
476: #define DEFAULT_SPECULAR_COEFFICIENT 0.04
477: float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
478: 	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
479: }
480: void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
481: 	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
482: 	vec3 irradiance = dotNL * directLight.color;
483: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
484: 		irradiance *= PI;
485: 	#endif
486: 	#ifndef STANDARD
487: 		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
488: 	#else
489: 		float clearCoatDHR = 0.0;
490: 	#endif
491: 	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
492: 	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
493: 	#ifndef STANDARD
494: 		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
495: 	#endif
496: }
497: void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
498: 	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
499: }
500: void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
501: 	#ifndef STANDARD
502: 		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
503: 		float dotNL = dotNV;
504: 		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
505: 	#else
506: 		float clearCoatDHR = 0.0;
507: 	#endif
508: 	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
509: 	#ifndef STANDARD
510: 		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
511: 	#endif
512: }
513: #define RE_Direct				RE_Direct_Physical
514: #define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
515: #define RE_IndirectSpecular		RE_IndirectSpecular_Physical
516: #define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
517: #define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
518: float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
519: 	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
520: }
521: 
522: #endif
523: 
524: bool interior = false;
525: 
526: float calcClip( vec4 cameraPos ){
527:     return dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );
528: }
529: 
530: float calcClip( vec3 cameraPos ){
531:     return calcClip( vec4( cameraPos, 1.0 ) );
532: }
533: 
534: float calcDepth( in vec3 cameraPos ){
535:     vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;
536:     return 0.5 + 0.5 * clipZW.x / clipZW.y;
537: }
538: 
539: struct Ray {
540:     vec3 origin ;
541:     vec3 direction ;
542: };
543: 
544: bool cutoff_plane (vec3 M, vec3 cutoff, vec3 x3){
545:     float a = x3.x;
546:     float b = x3.y;
547:     float c = x3.z;
548:     float d = -x3.x*cutoff.x-x3.y*cutoff.y-x3.z*cutoff.z;
549:     float l = a*M.x+b*M.y+c*M.z+d;
550:     if (l<0.0) {return true;}
551:     else{return false;}
552: }
553: 
554: vec3 isect_surf(Ray r, mat4 matrix_coef){
555:     vec4 direction = vec4(r.direction, 0.0);
556:     vec4 origin = vec4(r.origin, 1.0);
557:     float a = dot(direction,(matrix_coef*direction));
558:     float b = dot(origin,(matrix_coef*direction));
559:     float c = dot(origin,(matrix_coef*origin));
560:     float delta =b*b-a*c;
561:     gl_FragColor.a = 1.0;
562:     if (delta<0.0){
563:         discard;
564:         // gl_FragColor.a = 0.5;
565:     }
566:     float t1 =(-b-sqrt(delta))/a;
567: 
568:     // Second solution not necessary if you don't want
569:     // to see inside spheres and cylinders, save some fps
570:     //float t2 = (-b+sqrt(delta)) / a  ;
571:     //float t =(t1<t2) ? t1 : t2;
572: 
573:     return r.origin+t1*r.direction;
574: }
575: 
576: vec3 isect_surf2(Ray r, mat4 matrix_coef){
577:     vec4 direction = vec4(r.direction, 0.0);
578:     vec4 origin = vec4(r.origin, 1.0);
579:     float a = dot(direction,(matrix_coef*direction));
580:     float b = dot(origin,(matrix_coef*direction));
581:     float c = dot(origin,(matrix_coef*origin));
582:     float delta =b*b-a*c;
583:     gl_FragColor.a = 1.0;
584:     if (delta<0.0){
585:         discard;
586:         // gl_FragColor.a = 0.5;
587:     }
588:     float t2 =(-b+sqrt(delta))/a;
589: 
590:     return r.origin+t2*r.direction;
591: }
592: 
593: Ray primary_ray(vec4 near1, vec4 far1){
594:     vec3 near=near1.xyz/near1.w;
595:     vec3 far=far1.xyz/far1.w;
596:     return Ray(near,far-near);
597: }
598: 
599: float update_z_buffer(vec3 M, mat4 ModelViewP){
600:     float  depth1;
601:     vec4 Ms=(ModelViewP*vec4(M,1.0));
602:     return depth1=(1.0+Ms.z/Ms.w)/2.0;
603: }
604: 
605: void main(){
606: 
607:     //float radius = max( vRadius, vRadius2 );
608:     float radius = max( vRadius1, vRadius2 );
609: 
610:     vec4 i_near, i_far, focus;
611:     vec3 e3, e1, e1_temp, e2;
612: 
613:     i_near = vec4(matrix_near[0][0],matrix_near[0][1],matrix_near[0][2],matrix_near[0][3]);
614:     i_far  = vec4(matrix_near[1][0],matrix_near[1][1],matrix_near[1][2],matrix_near[1][3]);
615:     focus = vec4(matrix_near[2][0],matrix_near[2][1],matrix_near[2][2],matrix_near[2][3]);
616:     e3 = vec3(matrix_near[3][0],matrix_near[3][1],matrix_near[3][2]);
617: 
618:     e1.x = 1.0;
619:     e1.y = 1.0;
620:     e1.z = ( (e3.x*focus.x + e3.y*focus.y + e3.z*focus.z) - e1.x*e3.x - e1.y*e3.y)/e3.z;
621:     e1_temp = e1 - focus.xyz;
622:     e1 = normalize(e1_temp);
623: 
624:     e2 = normalize(cross(e1,e3));
625: 
626:     vec4 equation = focus;
627: 
628:     float shrinkfactor = shrink;
629:     float t1 = -1.0/(1.0-shrinkfactor);
630:     float t2 = 1.0/(shrinkfactor);
631:     // float t3 = 2.0/(shrinkfactor);
632: 
633:     vec4 colonne1, colonne2, colonne3, colonne4;
634:     mat4 mat;
635: 
636:     vec3 equation1 = vec3(t2,t2,t1);
637: 
638:     float A1 = - e1.x*equation.x - e1.y*equation.y - e1.z*equation.z;
639:     float A2 = - e2.x*equation.x - e2.y*equation.y - e2.z*equation.z;
640:     float A3 = - e3.x*equation.x - e3.y*equation.y - e3.z*equation.z;
641: 
642:     float A11 = equation1.x*e1.x*e1.x +  equation1.y*e2.x*e2.x + equation1.z*e3.x*e3.x;
643:     float A21 = equation1.x*e1.x*e1.y +  equation1.y*e2.x*e2.y + equation1.z*e3.x*e3.y;
644:     float A31 = equation1.x*e1.x*e1.z +  equation1.y*e2.x*e2.z + equation1.z*e3.x*e3.z;
645:     float A41 = equation1.x*e1.x*A1   +  equation1.y*e2.x*A2   + equation1.z*e3.x*A3;
646: 
647:     float A22 = equation1.x*e1.y*e1.y +  equation1.y*e2.y*e2.y + equation1.z*e3.y*e3.y;
648:     float A32 = equation1.x*e1.y*e1.z +  equation1.y*e2.y*e2.z + equation1.z*e3.y*e3.z;
649:     float A42 = equation1.x*e1.y*A1   +  equation1.y*e2.y*A2   + equation1.z*e3.y*A3;
650: 
651:     float A33 = equation1.x*e1.z*e1.z +  equation1.y*e2.z*e2.z + equation1.z*e3.z*e3.z;
652:     float A43 = equation1.x*e1.z*A1   +  equation1.y*e2.z*A2   + equation1.z*e3.z*A3;
653: 
654:     float A44 = equation1.x*A1*A1 +  equation1.y*A2*A2 + equation1.z*A3*A3 - equation.w;
655: 
656:     colonne1 = vec4(A11,A21,A31,A41);
657:     colonne2 = vec4(A21,A22,A32,A42);
658:     colonne3 = vec4(A31,A32,A33,A43);
659:     colonne4 = vec4(A41,A42,A43,A44);
660: 
661:     mat = mat4(colonne1,colonne2,colonne3,colonne4);
662: 
663:     // Ray calculation using near and far
664:     Ray ray = primary_ray(i_near,i_far) ;
665: 
666:     // Intersection between ray and surface for each pixel
667:     vec3 M;
668:     M = isect_surf(ray, mat);
669: 
670:     // cut the extremities of bonds to superimpose bond and spheres surfaces
671:     if (cutoff_plane(M, prime1.xyz, -e3) || cutoff_plane(M, prime2.xyz, e3)){ discard; }
672: 
673:     // Transform normal to model space to view-space
674:     vec4 M1 = vec4(M,1.0);
675:     vec4 M2 =  mat*M1;
676:     // vec3 _normal = normalize( ( modelViewMatrixInverseTranspose * M2 ).xyz );
677:     vec3 _normal = ( modelViewMatrixInverseTranspose * M2 ).xyz;
678: 
679:     // Recalculate the depth in function of the new pixel position
680:     gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;
681: 
682:     #ifdef NEAR_CLIP
683:         if( calcClip( modelViewMatrix * vec4( M, 1.0 ) ) > 0.0 ){
684:             M = isect_surf2(ray, mat);
685:             if( calcClip( modelViewMatrix * vec4( M, 1.0 ) ) > 0.0 )
686:                 discard;
687:             interior = true;
688:             gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;
689:             if( gl_FragDepthEXT >= 0.0 ){
690:                 gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / radius ) );
691:             }
692:         }else if( gl_FragDepthEXT <= 0.0 ){
693:             M = isect_surf2(ray, mat);
694:             interior = true;
695:             gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix);
696:             if( gl_FragDepthEXT >= 0.0 ){
697:                 gl_FragDepthEXT = 0.0 + ( 0.0000001 / radius );
698:             }
699:         }
700:     #else
701:         if( gl_FragDepthEXT <= 0.0 ){
702:             M = isect_surf2(ray, mat);
703:             interior = true;
704:             gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;
705:             if( gl_FragDepthEXT >= 0.0 ){
706:                 gl_FragDepthEXT = 0.0 + ( 0.0000001 / radius );
707:             }
708:         }
709:     #endif
710: 
711:     // cut the extremities of bonds to superimpose bond and spheres surfaces
712:     if (cutoff_plane(M, prime1.xyz, -e3) || cutoff_plane(M, prime2.xyz, e3)){ discard; }
713: 
714:     if (gl_FragDepthEXT < 0.0)
715:         discard;
716:     if (gl_FragDepthEXT > 1.0)
717:         discard;
718: 
719:     // Mix the color bond in function of the two atom colors
720:     float distance_ratio = ((M.x-prime2.x)*e3.x + (M.y-prime2.y)*e3.y +(M.z-prime2.z)*e3.z) /
721:                                 distance(prime2.xyz,prime1.xyz);
722: 
723:     #ifdef PICKING
724: 
725:         gl_FragColor = vec4( vPickingColor, objectId );
726: 
727:     #else
728: 
729:         vec3 vViewPosition = -( modelViewMatrix * vec4( M, 1.0 ) ).xyz;
730:         vec3 vNormal = _normal;
731:         vec3 vColor;
732: 
733:         if( distance_ratio>0.5 ){
734:             vColor = vColor1;
735:         }else{
736:             vColor = vColor2;
737:         }
738: 
739:         vec4 diffuseColor = vec4( diffuse, opacity );
740:         ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
741:         vec3 totalEmissiveLight = emissive;
742: 
743:         #ifdef USE_COLOR
744: 	diffuseColor.rgb *= vColor;
745: #endif
746:         float roughnessFactor = roughness;
747: #ifdef USE_ROUGHNESSMAP
748: 	vec4 texelRoughness = texture2D( roughnessMap, vUv );
749: 	roughnessFactor *= texelRoughness.r;
750: #endif
751: 
752:         float metalnessFactor = metalness;
753: #ifdef USE_METALNESSMAP
754: 	vec4 texelMetalness = texture2D( metalnessMap, vUv );
755: 	metalnessFactor *= texelMetalness.r;
756: #endif
757: 
758: 
759:         // don't use include normal_fragment
760:         vec3 normal = normalize( vNormal );
761:         if( interior ){
762:             normal = vec3( 0.0, 0.0, 0.4 );
763:         }
764: 
765:         PhysicalMaterial material;
766: material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
767: material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
768: #ifdef STANDARD
769: 	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
770: #else
771: 	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
772: 	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
773: #endif
774: 
775:         
776: GeometricContext geometry;
777: geometry.position = - vViewPosition;
778: geometry.normal = normal;
779: geometry.viewDir = normalize( vViewPosition );
780: IncidentLight directLight;
781: #if ( 0 > 0 ) && defined( RE_Direct )
782: 	PointLight pointLight;
783: 	for ( int i = 0; i < 0; i ++ ) {
784: 		pointLight = pointLights[ i ];
785: 		getPointDirectLightIrradiance( pointLight, geometry, directLight );
786: 		#ifdef USE_SHADOWMAP
787: 		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;
788: 		#endif
789: 		RE_Direct( directLight, geometry, material, reflectedLight );
790: 	}
791: #endif
792: #if ( 0 > 0 ) && defined( RE_Direct )
793: 	SpotLight spotLight;
794: 	for ( int i = 0; i < 0; i ++ ) {
795: 		spotLight = spotLights[ i ];
796: 		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
797: 		#ifdef USE_SHADOWMAP
798: 		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
799: 		#endif
800: 		RE_Direct( directLight, geometry, material, reflectedLight );
801: 	}
802: #endif
803: #if ( 1 > 0 ) && defined( RE_Direct )
804: 	DirectionalLight directionalLight;
805: 	for ( int i = 0; i < 1; i ++ ) {
806: 		directionalLight = directionalLights[ i ];
807: 		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
808: 		#ifdef USE_SHADOWMAP
809: 		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
810: 		#endif
811: 		RE_Direct( directLight, geometry, material, reflectedLight );
812: 	}
813: #endif
814: #if defined( RE_IndirectDiffuse )
815: 	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
816: 	#ifdef USE_LIGHTMAP
817: 		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
818: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
819: 			lightMapIrradiance *= PI;
820: 		#endif
821: 		irradiance += lightMapIrradiance;
822: 	#endif
823: 	#if ( 0 > 0 )
824: 		for ( int i = 0; i < 0; i ++ ) {
825: 			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
826: 		}
827: 	#endif
828: 	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
829: 	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );
830: 	#endif
831: 	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
832: #endif
833: #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
834: 	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );
835: 	#ifndef STANDARD
836: 		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );
837: 	#else
838: 		vec3 clearCoatRadiance = vec3( 0.0 );
839: 	#endif
840: 		
841: 	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
842: #endif
843: 
844: 
845:         vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;
846: 
847:         gl_FragColor = vec4( outgoingLight, diffuseColor.a );
848: 
849:         #ifdef PREMULTIPLIED_ALPHA
850: 	gl_FragColor.rgb *= gl_FragColor.a;
851: #endif
852: 
853:         #if defined( TONE_MAPPING )
854:   gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
855: #endif
856: 
857:           gl_FragColor = linearToOutputTexel( gl_FragColor );
858: 
859:         #ifdef USE_FOG
860: 	#ifdef USE_LOGDEPTHBUF_EXT
861: 		float depth = gl_FragDepthEXT / gl_FragCoord.w;
862: 	#else
863: 		float depth = gl_FragCoord.z / gl_FragCoord.w;
864: 	#endif
865: 	#ifdef FOG_EXP2
866: 		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );
867: 	#else
868: 		float fogFactor = smoothstep( fogNear, fogFar, depth );
869: 	#endif
870: 	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
871: #endif
872: 
873: 
874:     #endif
875: 
876: }